Wprowadzenie
Celem niniejszego projektu jest zastosowanie modelu regresji liniowej w procesie prognozowania liczby ludności wybranych krajów z wykorzystaniem danych World Population Dataset dostępnych pod adresem https://www.kaggle.com/datasets/iamsouravbanerjee/world-population-dataset .
Baza danych zawiera informacje na temat liczby ludności w latach 2022, 2020, 2015, 2010, 2000, 1990, 1980 i 1970 dla wszystkich państw świata z uwzględnieniem takich parametrów jak miejsce na liście wg liczby ludności, trzyliterowy kod państwa, nazwa stolicy i kontynentu, powierzchnia państwa, gęstość zaludnienia, przyrost populacji oraz udział danego państwa w światowej populacji.
Zastosowana metoda regresji polega na dopasowaniu do danych linii prostej opisującej zależność między zmiennymi wejściowymi (rok) a danymi wyjściowymi (liczba ludności).

1.	Analiza i wizualizacja danych
Pierwszym krokiem jest zaimportowanie niezbędnych bibliotek, tj. pandas do manipulacji i analizy danych, seaborn i matplotlib na potrzeby wizualizacji danych.
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

Pobranie danych
Dane w formie pliku csv zostały pobrane z bazy dostępnej na https://www.kaggle.com/datasets/iamsouravbanerjee/world-population-dataset .
df = pd.read_csv('world_population.csv')


Analiza danych
W celu uzyskania ogólnego obrazu danych z uwzględnieniem wszystkich kolumn zastosowana została metody head() oraz to_string().
print(df.head().to_string())



Stosując metodę describe() można dodatkowo uzyskać statystki opisowe, w tym m.in. średnią, wartości minimalną i maksymalną, odchylenie standardowe i kwantyle.
print(df.describe().to_string())

Z kolei metoda info() wskazuje m.in liczbę wierszy, kolumn oraz typ danych znajdujących się w kolumnach.
print(df.info())



Informację na temat liczby wierszy i kolumn można również uzyskać dzięki metodzie shape().
print(df.shape)



W celu zidentyfikowania sumy brakujących danych można zastosować metody isna() wraz z funkcją sum().
print(df.isna().sum())

Dostępne dane można pogrupować przy pomocy metody groupby(), np. według kontynentu, agregując dane według liczby ludności w 2022 r. (kolumna 2022 Population),  a następnie posortować według średniej liczby ludności. W ten sposób można uzyskać listę kontynentów zaczynając od obszaru o najmniejszej liczbie ludności w 2022 r.
print(df.groupby('Continent')['2022 Population'].mean().sort_values())



Na podstawie zbioru danych można przygotować listę dziesięciu najludniejszych państw świata, ponownie stosując metodę sort_values malejąco i wyświetlając dziesięć pierwszych wyników.
top_ten = df.sort_values('2022 Population', ascending=False).head(10)
print(top_ten.to_string())


Listę państw o największej liczbie ludności w 2022 r. można również przedstawić w formie wykresu, gdzie oś x to liczba ludności, a oś y to państwo, wykorzystując wcześniej zdefiniowaną zmienna top_ten.
plt.figure(figsize=(10, 6))
sns.barplot(x='2022 Population', y='Country/Territory', data=top_ten, hue='Country/Territory')
plt.title('Top ten most populous countries (2022)')
plt.xlabel('Population')
plt.ylabel('Country/Territory')
plt.show()





Kolejny wykres przedstawia porównanie liczby ludności Polski i Hiszpanii w 2022 r. W celu jego przygotowania zdefiniowane zostały dwie zmienne: poland_population i spain_population

poland_population = df.loc[df['Country/Territory']=='Poland', '2022 Population'].values[0]
spain_population = df.loc[df['Country/Territory']=='Spain', '2022 Population'].values[0]

plt.figure(figsize=(10, 6))
plt.bar(['Poland', 'Spain'], [poland_population, spain_population])
plt.xlabel('Country/Territory')
plt.ylabel('2022 Population')
plt.title('Population comparison: Poland vs. Spain')
plt.show()




2.	Model regresji liniowej
Kolejnym etapem jest proces uczenia modelu regresji liniowej na podstawie danych dotyczących najludniejszego państwa świata, tj. Chin (zmienne niezależne to lata, a zmienne zależne to liczba ludności). W tym celu konieczne jest zaimportowanie biblioteki sklearn służącej do wykonywania operacji uczenia maszynowego oraz joblib niezbędnej do zapisania modelu.
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import joblib


df = pd.read_csv('world_population.csv')


Przyjmując, że danymi uczącymi będą poszczególne lata, konieczna jest zmiana nazwy kolumn zawierających liczbę ludności, tak aby nazwa składała się jedynie z liczby całkowitej.
df = df.rename(columns={'2022 Population': '2022',
                        '2020 Population': '2020',
                        '2015 Population': '2015',
                        '2010 Population': '2010',
                        '2000 Population': '2000',
                        '1990 Population': '1990',
                        '1980 Population': '1980',
                        '1970 Population': '1970'})
print(df.head().to_string())

Zastosowane w następnym kroku df.loc pozwala uzyskać wiersz i kolumny z danymi dotyczącymi China. Z uwagi na fakt, że danymi wyjściowymi będzie liczba ludności wszystkie pozostałe kolumny są zbędne (w celu ich usunięcia zastosowano metodę drop() wraz z argumentami axis (1 dla kolumn) oraz inplace (w celu wprowadzenia zmian dla bieżącej ramki danych).

china_population = df.loc[df['Country/Territory']=='China']
china_population.drop(['Rank','CCA3','Capital','Continent', 'Area (km²)',
            'Density (per km²)', 'Growth Rate', 'World Population Percentage'],axis=1, inplace=True)


Na potrzeby modelu wiersze zostaną zamienione z kolumnami dzięki atrybutowi T. W ten sposób zamiast jednego wiersza i 9 kolumn powstaną dwie kolumny. Docelowo pierwsza z nich powinna zawierać poszczególne lata, a druga liczbę ludności.
china_population = china_population.T
print(china_population.head(8))



Pozostały po zamianie wiersz pierwszy nie jest konieczny na potrzeby obliczeń, dlatego też może być usunięty (z wykorzystaniem metody drop() i argumentów axis (0 dla wiersza) oraz inplace). Dla powstałych kolumn można również przywrócić domyślne indeksowanie (przy pomocy metody reset.index()) oraz nadać nowe nazwy (Year i Population).

china_population = china_population.reset_index().rename(columns={'index':'Year', 41:'Population'})
china_population.drop(0, axis=0, inplace=True)
print(china_population.head(8))




Ponadto, na obecnym etapie dane wejściowe i wyjściowe mają charakter jednowymiarowej tablicy.
print(china_population.iloc[:, 0].ndim)
print(china_population.iloc[:, 0].shape)


W celu zapewnienia, że dane wejściowe i wyjściowe mają charakter dwuwymiarowej tablicy konieczne jest zastosowanie metody reshape, która pozwala na dodanie brakującego wymiaru (gdzie -1 oznacza, że podana ilość elementów pozostanie niezmieniona, a 1 to dodany wymiar).

X = china_population.iloc[:, 0].values.reshape(-1, 1)
y = china_population.iloc[:, 1].values.reshape(-1, 1)

Mając przygotowane dane można przejść do ich podzielenia na zestaw uczący i zestaw walidacyjny/testowy przy pomocy train_test_split.

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

Kolejnym etapem procesu jest uczenie modelu na podstawie zestawu uczącego.
model = LinearRegression()
model.fit(X_train, y_train)

Ostatnim etapem jest ewaluacja modelu na podstawie zestawu testowego.
print(model.score(X_test, y_test))



Po zakończeniu procesu uczenia model można zapisać do pliku za pomocą joblib.dump, a następnie odtworzyć (joblib.load).
joblib.dump(model, 'Linear_regression.model')

model_1 = joblib.load('Linear_regression.model')

3.	Funkcja
Przygotowany model może być wykorzystany do przewidywania wartości dla krajów innych niż Chiny. Dlatego też przydatne może być stworzenie funkcji, która będzie przyjmowała dwa argumenty: kraj i rok.
Wcześniej przygotowany kod został wobec tego przeniesiony do osobnej funkcji, a odniesienia do danego kraju zostały zastąpione parametrem country. Dodatkowo, zamiast metody rename(), użyta została metoda set_axis, ponieważ indeks, który będzie musiał być zastąpiony nazwą Population będzie zawsze zależał od kraju wskazanego jako argument funkcji.

country_population = country_population.reset_index().set_axis(['Year', 'Population'], axis='columns')

Funkcja ma następującą postać:
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split


def predict_population(country):
    df = pd.read_csv('world_population.csv')
    df = df.rename(columns={'2022 Population': '2022',
                        '2020 Population': '2020',
                        '2015 Population': '2015',
                        '2010 Population': '2010',
                        '2000 Population': '2000',
                        '1990 Population': '1990',
                        '1980 Population': '1980',
                        '1970 Population': '1970'})


    country_population = df.loc[df['Country/Territory']==country]
    country_population.drop(['Rank','CCA3','Capital','Continent', 'Area (km²)',
            'Density (per km²)', 'Growth Rate', 'World Population Percentage'],axis=1, inplace=True)
    country_population = country_population.T
    country_population = country_population.reset_index().set_axis(['Year', 'Population'], axis='columns')
    country_population.drop(0, axis=0, inplace=True)
    # print(country_population.head(8))

    X = country_population.iloc[:, 0].values.reshape(-1, 1)
    y = country_population.iloc[:, 1].values.reshape(-1, 1)


    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
    model = LinearRegression()
    model.fit(X_train, y_train)

    print(f'The accuracy of the model is {model.score(X_test, y_test)}.')


predict_population('India')


